AWSTemplateFormatVersion: 2010-09-09
Description: Common-ScheduleFunctions Template.
  This creates standard Lambda Functions related to Scheduling. This supports an ability to turn Instances on and off to reduce costs.
  This is a placeholder example, still in Python, that isn't designed very well, but has the right idea. I am leaving this here as a
  reminder we likely need something like this in the future, and will rewrite this in Node.js with a better design when I can get to it.
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Stack Dependencies
        Parameters:
          - LayersStackName
          - BucketsStackName
          - TopicsStackName
      - Label:
          default: Function Configuration
        Parameters:
          - SchedulerLogRetention
    ParameterLabels:
      LayersStackName:
        default: Layers Stack Name
      BucketsStackName:
        default: Buckets Stack Name
      TopicsStackName:
        default: Topics Stack Name
      SchedulerLogRetention:
        default: Scheduler Log Retention
Parameters:
  LayersStackName:
    Description: Name of the CloudFormation Stack containing Layers
    Type: String
    MinLength: 2
    MaxLength: 64
    Default: Layers
    AllowedPattern: ^[A-Z][-a-zA-Z0-9]*$
    ConstraintDescription: must begin with an upper case letter and contain alphanumeric characters and dashes.
  BucketsStackName:
    Description: Name of the CloudFormation Stack containing Buckets
    Type: String
    MinLength: 2
    MaxLength: 64
    Default: Buckets
    AllowedPattern: ^[A-Z][-a-zA-Z0-9]*$
    ConstraintDescription: must begin with an upper case letter and contain alphanumeric characters and dashes.
  TopicsStackName:
    Description: Name of the CloudFormation Stack containing Topics
    Type: String
    MinLength: 2
    MaxLength: 64
    Default: Topics
    AllowedPattern: ^[A-Z][-a-zA-Z0-9]*$
    ConstraintDescription: must begin with an upper case letter and contain alphanumeric characters and dashes.
  SchedulerLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the Scheduler Lambda Function
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: 'must be: 1, 3, 5, 7, 14, 30, 60 or 90.'
Resources:
  SchedulerRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ManageInstancesPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ec2:StartInstances
                  - ec2:StopInstances
                  - ec2:RebootInstances
                  - ec2:TerminateInstances
                Resource: '*'
  SchedulerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/Scheduler
      RetentionInDays: !Ref SchedulerLogRetention
  SchedulerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: Scheduler
      Description: A Lambda function which starts, stops and/or terminates Instances based on a Schedule Tag.
      Role: !GetAtt SchedulerRole.Arn
      Runtime: python2.7
      Timeout: 30
      Handler: index.Scheduler
      Code:
        ZipFile: |
          from datetime import datetime, time
          import boto3
          import re

          theTag='Schedule'

          doLog = True

          def Scheduler(event, context):

            now = datetime.now().replace(second=0, microsecond=0)

            if doLog:
              print 'Reference time is ', now.time()

            ec2 = boto3.resource('ec2')

            allInstances = ec2.instances.filter(Filters=[{'Name': 'instance-state-name', 'Values': ['running', 'stopped']}])

            for instance in allInstances:
              if instance.tags :
                for tag in instance.tags:
                  if tag['Key'] == theTag :
                    Range=tag['Value']

                    if doLog :
                      print instance.instance_id,

                    shouldrun=shouldRunNow(instance, now, Range)

                    if doLog :
                      print 'should %s' %( 'run' if shouldrun else 'NOT run'),

                    alignInstance(instance, shouldrun)

          def shouldRunNow(instance, now, tRange):

            currentState = instance.state['Code'] == 16

            # is the tRange commented out

            if tRange[0:1] == '#':
              if doLog:
                print 'Range starts with # -- no changes',
              return currentState

            # does the time indicate an end-time only [eg -13:15]

            if tRange[0:1] == '-':
              tEnd=time(int(tRange[1:3]),int(tRange[4:6]))

              if doLog:
                print 'End time:', tEnd,

              if now.time() > tEnd:

                msg='stop'
                if tRange[6:7] == 'T':

                  terminateAllowed=instance.describe_attribute(Attribute='disableApiTermination')['DisableApiTermination']['Value'] == False

                  if terminateAllowed:
                    instance.modify_attribute( Attribute='instanceInitiatedShutdownBehavior', Value='terminate' )
                    msg='terminate'
                  else:
                    msg='stop [terminate not allowed]'

                # re-tag

                instance.delete_tags(Tags=[{'Key': theTag, 'Value': tRange}])
                instance.create_tags(Tags=[{'Key': theTag, 'Value': '#'+msg+'@'+tRange}])

                if doLog:
                  print 'time to ', msg,

                return False

              else:
                # leave instance in current state
                if doLog:
                  print 'NO time to stop (yet) ',
                return currentState

            # some simple checks for tRange

            if not re.match('\\d{2}:\\d{2}-\\d{2}:\\d{2}',tRange):
              if doLog:
                print 'error in format of tag: >', tRange, '< -- no changes required ',

              instance.delete_tags(Tags=[{'Key': theTag}, {'Value': tRange}])
              instance.create_tags(Tags=[{'Key': theTag, 'Value': '# Err: '+tRange}])

              return currentState

            tStart=time(int(tRange[0:2]),int(tRange[3:5]))
            tEnd=time(int(tRange[6:8]),int(tRange[9:11]))

            inInterval = False

            # first case, start < end --> same day

            if tStart < tEnd:
              if tStart <= now.time() <= tEnd:
                inInterval = True

            # second case, end < start --> carry over to next day

            else:
              if tStart <= now.time() <= time(23,59) or time(0,0) <= now.time() <= tEnd:
                inInterval = True

            if doLog :
              print 'Ref time is %s interval' %( 'in' if inInterval else 'NOT in'), tRange,

            return inInterval

          def alignInstance(inst, requiredOn):

            actualOn = inst.state['Code'] == 16
            msg='is compliant'

            if actualOn != requiredOn:
              if requiredOn == True:
                msg='starting'
                inst.start()
              else:
                termReq=inst.describe_attribute(Attribute='instanceInitiatedShutdownBehavior')['InstanceInitiatedShutdownBehavior']['Value'] == 'terminate'

                if termReq:
                  msg='terminating'
                  inst.terminate()
                else:
                  msg='stopping'
                  inst.stop()

            if doLog:
              print '-->', msg

  SchedulerRule:
    Type: AWS::Events::Rule
    Properties:
      Name: SchedulerRule
      Description: ScheduledRule for Scheduler
      ScheduleExpression: rate(10 minutes)
      State: ENABLED
      Targets:
        - Id: SchedulerFunction
          Arn: !GetAtt SchedulerFunction.Arn
  SchedulerPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref SchedulerFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt SchedulerRule.Arn
  SchedulerErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: The number of ERRORs is greater than 5 over 1 minute
      AlarmActions:
        - !ImportValue
          Fn::Sub: ${TopicsStackName}-AlarmsTopic
      Namespace: AWS/Lambda
      MetricName: Errors
      Statistic: Sum
      Period: 60
      EvaluationPeriods: 1
      Threshold: 5
      ComparisonOperator: GreaterThanThreshold
Outputs:
  SchedulerFunctionArn:
    Description: The Scheduler Lambda Function ARN
    Value: !GetAtt SchedulerFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-SchedulerFunctionArn
