AWSTemplateFormatVersion: 2010-09-09
Description: Common-CIDRFunctions Template.
  This creates Lambda Functions related to CIDRs and Network Address Calculation.
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Stack Dependencies
        Parameters:
          - LayersStackName
          - BucketsStackName
          - TopicsStackName
      - Label:
          default: Function Configuration
        Parameters:
          - LogRetention
    ParameterLabels:
      LayersStackName:
        default: Layers Stack Name
      BucketsStackName:
        default: Buckets Stack Name
      TopicsStackName:
        default: Topics Stack Name
      LogRetention:
        default: Log Retention
Parameters:
  LayersStackName:
    Description: Name of the CloudFormation Stack containing Layers
    Type: String
    MinLength: 2
    MaxLength: 64
    Default: Layers
    AllowedPattern: ^[A-Z][-a-zA-Z0-9]*$
    ConstraintDescription: must begin with an upper case letter and contain alphanumeric characters and dashes.
  BucketsStackName:
    Description: Name of the CloudFormation Stack containing Buckets
    Type: String
    MinLength: 2
    MaxLength: 64
    Default: Buckets
    AllowedPattern: ^[A-Z][-a-zA-Z0-9]*$
    ConstraintDescription: must begin with an upper case letter and contain alphanumeric characters and dashes.
  TopicsStackName:
    Description: Name of the CloudFormation Stack containing Topics
    Type: String
    MinLength: 2
    MaxLength: 64
    Default: Topics
    AllowedPattern: ^[A-Z][-a-zA-Z0-9]*$
    ConstraintDescription: must begin with an upper case letter and contain alphanumeric characters and dashes.
  LogRetention:
    Description: Number of days to retain CloudWatch Log Events for all AMI Lookup Lambda Functions
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: 'must be: 1, 3, 5, 7, 14, 30, 60 or 90.'
Resources:
  Role:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DescribeSubnetsPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeSubnets
                Resource: '*'
  SubnetCalculatorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/SubnetCalculator
      RetentionInDays: !Ref LogRetention
  SubnetCalculatorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: SubnetCalculator
      Description: A Lambda function which calculates Subnet CIDRs for use in a VPC, based on the VPC CIDR, Addresses per Subnet, Subnets per Availability Zone and Availability Zones.
      Role: !GetAtt Role.Arn
      Runtime: nodejs8.10
      Timeout: 30
      Layers:
        - !ImportValue
            Fn::Sub: ${LayersStackName}-AsyncCustomResourceLayerVersionArn
      Handler: index.handler
      Code:
        ZipFile: |
          const addressesToNetmask = {
            '16':    '28',
            '32':    '27',
            '64':    '26',
            '128':   '25',
            '256':   '24',
            '512':   '23',
            '1024':  '22',
            '2048':  '21',
            '4096':  '20',
            '8192':  '19',
            '16384': '18',
            '32768': '17',
            '65536': '16'
          };

          const response = require('cfn-response');

          exports.handler = function(event, context) {
            console.info('Request body:\n' + JSON.stringify(event));

            let responseData = {};
            let params = {};

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                let vpcCidrBlock = event.ResourceProperties.VpcCidrBlock;
                if (! /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(1[6-9]|2[0-7]))$/.test(vpcCidrBlock)) {
                  responseData = {Error: 'VpcCidrBlock invalid: must be a valid IP CIDR range of the form x.x.x.x/x, with a size from /16 to /27'};
                  console.error('Error: ' + responseData.Error);
                  response.send(event, context, response.FAILED, responseData);
                  return;
                }
                let addresses = parseInt(event.ResourceProperties.Addresses, 10);
                if (! /^(16|32|64|128|256|512|1024|2048|4096)$/.test(addresses)) {
                  responseData = {Error: 'Addresses invalid: must be 16, 32, 64, 128, 256, 512, 1024, 2048 or 4096'};
                  console.error('Error: ' + responseData.Error);
                  response.send(event, context, response.FAILED, responseData);
                  return;
                }
                let subnets = parseInt(event.ResourceProperties.Subnets, 10);
                if (! /^(2|4|8|16|32|64)$/.test(subnets)) {
                  responseData = {Error: 'Subnets invalid: must be 2, 4, 8, 16, 32 or 64'};
                  console.error('Error: ' + responseData.Error);
                  response.send(event, context, response.FAILED, responseData);
                  return;
                }
                let zones = parseInt(event.ResourceProperties.AvailabilityZones, 10);
                if (! /^(1|2|4)$/.test(zones)) {
                  responseData = {Error: 'AvailabilityZones invalid: must be 1, 2 or 4'};
                  console.error('Error: ' + responseData.Error);
                  response.send(event, context, response.FAILED, responseData);
                  return;
                }

                let vpcOctets = vpcCidrBlock.split('/')[0].split('.');
                let vpcNetmask = vpcCidrBlock.split('/')[1];
                let vpcDecimal = ((((((+vpcOctets[0]) * 256) + (+vpcOctets[1])) * 256) + (+vpcOctets[2])) * 256) + (+vpcOctets[3]);

                if (vpcDecimal % Math.pow(2, 32 - vpcNetmask) !== 0) {
                  responseData = {Error: 'VpcCidrBlock invalid: not aligned on the correct boundary for a /' + vpcNetmask + ' netmask'};
                  console.error('Error: ' + responseData.Error);
                  response.send(event, context, response.FAILED, responseData);
                  return;
                }

                let vpcRequestedAddresses = addresses * subnets * zones;
                let vpcRequestedNetmask = addressesToNetmask[vpcRequestedAddresses];

                if (vpcNetmask != vpcRequestedNetmask) {
                  responseData = {Error: 'VpcCidrBlock invalid: incorrect size - a /' + vpcRequestedNetmask + ' netmask is needed'};
                  console.error('Error: ' + responseData.Error);
                  response.send(event, context, response.FAILED, responseData);
                  return;
                }

                for (var zone = 0; zone < zones; zone++) {
                  for (var subnet = 0; subnet < subnets; subnet++) {
                    let subnetDecimal = vpcDecimal + (addresses * (subnet + (subnets * zone)));
                    responseData['Subnet'+ subnet + String.fromCharCode(65 + zone)]
                      = (subnetDecimal >>> 24)       + '.'
                      + (subnetDecimal >>  16 & 255) + '.'
                      + (subnetDecimal >>   8 & 255) + '.'
                      + (subnetDecimal        & 255) + '/'
                      + addressesToNetmask[addresses];
                  }
                }

                response.send(event, context, response.SUCCESS, responseData);
                break;

              case 'Delete':
                response.send(event, context, response.SUCCESS);
                break;
            }
          };
  AddressCalculatorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/AddressCalculator
      RetentionInDays: !Ref LogRetention
  AddressCalculatorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: AddressCalculator
      Description: A Lambda function which calculates Addresses for use in a VPC Subnet, based on the Subnet CIDR obtained from a Subnet ID.
      Role: !GetAtt Role.Arn
      Runtime: nodejs8.10
      Timeout: 30
      Layers:
        - !ImportValue
            Fn::Sub: ${LayersStackName}-AsyncCustomResourceLayerVersionArn
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response');

          exports.handler = function(event, context) {
            console.info('Request body:\n' + JSON.stringify(event));

            let responseData = {};
            let params = {};

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                let region = (event.ResourceProperties.Region) ? event.ResourceProperties.Region : process.env.AWS_REGION;
                let subnetId = event.ResourceProperties.SubnetId;
                if (! /^subnet-[0-9a-f]{17}$/.test(subnetId)) {
                  responseData = {Error: 'SubnetId invalid: must be valid Subnet ID'};
                  console.error('Error: ' + responseData.Error);
                  response.send(event, context, response.FAILED, responseData);
                  return;
                }

                const AWS = require('aws-sdk');
                AWS.config.update({region: region});
                AWS.config.apiVersions = {
                  ec2: '2016-11-15'
                };

                const ec2 = new AWS.EC2();

                console.info('Calling: DescribeSubnets...');
                params = {
                  Filters: [{ Name: 'subnet-id', Values: [subnetId]}]
                };
                ec2.describeSubnets(params, function(err, data) {
                  if (err) {
                    responseData = {Error: 'DescribeSubnets call failed'};
                    console.error('Error: ' + responseData.Error + ':\n', err);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    if (data.Subnets.length > 0) {
                      let subnetCidrBlock = data.Subnets[0].CidrBlock;
                      console.info('Subnet: ' + subnetId + ' = ' + subnetCidrBlock);
                      let subnetAddress = subnetCidrBlock.split('/')[0];
                      let subnetNetmask = subnetCidrBlock.split('/')[1];
                      let subnetOctets = subnetAddress.split('.');
                      let subnetDecimal = ((((((+subnetOctets[0]) * 256) + (+subnetOctets[1])) * 256) + (+subnetOctets[2])) * 256) + (+subnetOctets[3]);

                      console.info('Calculating: Addresses...');
                      for (var offset = 4; offset < Math.pow(2, 32 - subnetNetmask) - 1; offset++) {
                        let addressDecimal = subnetDecimal + offset;
                        responseData['Address' + offset]
                          = (addressDecimal >>> 24)       + '.'
                          + (addressDecimal >>  16 & 255) + '.'
                          + (addressDecimal >>   8 & 255) + '.'
                          + (addressDecimal        & 255);
                      }
                      response.send(event, context, response.SUCCESS, responseData);
                    }
                    else {
                      responseData = {Error: 'Could not find ' + subnetId + ' Subnet'};
                      console.error('Error: ' + responseData.Error);
                      response.send(event, context, response.FAILED, responseData);
                    }
                  }
                });
                break;

              case 'Delete':
                response.send(event, context, response.SUCCESS);
                break;

              default:
                responseData = {Error: 'Unknown operation: ' + event.RequestType};
                console.error('Error: ' + responseData.Error);
                response.send(event, context, response.FAILED, responseData);
            }
          };
Outputs:
  SubnetCalculatorFunctionArn:
    Description: The SubnetCalculator Lambda Function ARN
    Value: !GetAtt SubnetCalculatorFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-SubnetCalculatorFunctionArn
  AddressCalculatorFunctionArn:
    Description: The AddressCalculator Lambda Function ARN
    Value: !GetAtt AddressCalculatorFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-AddressCalculatorFunctionArn
