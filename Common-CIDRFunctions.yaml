AWSTemplateFormatVersion: 2010-09-09
Description: Common-CIDRFunctions Template.
  This creates Lambda Functions related to CIDRs and Network Address Calculation.
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Stack Dependencies
        Parameters:
          - LayersStackName
          - BucketsStackName
          - TopicsStackName
      - Label:
          default: Function Configuration
        Parameters:
          - LogRetention
    ParameterLabels:
      LayersStackName:
        default: Layers Stack Name
      BucketsStackName:
        default: Buckets Stack Name
      TopicsStackName:
        default: Topics Stack Name
      LogRetention:
        default: Log Retention
Parameters:
  LayersStackName:
    Description: Name of the CloudFormation Stack containing Layers
    Type: String
    MinLength: 2
    MaxLength: 64
    Default: Layers
    AllowedPattern: ^[A-Z][-a-zA-Z0-9]*$
    ConstraintDescription: must begin with an upper case letter and contain alphanumeric characters and dashes.
  BucketsStackName:
    Description: Name of the CloudFormation Stack containing Buckets
    Type: String
    MinLength: 2
    MaxLength: 64
    Default: Buckets
    AllowedPattern: ^[A-Z][-a-zA-Z0-9]*$
    ConstraintDescription: must begin with an upper case letter and contain alphanumeric characters and dashes.
  TopicsStackName:
    Description: Name of the CloudFormation Stack containing Topics
    Type: String
    MinLength: 2
    MaxLength: 64
    Default: Topics
    AllowedPattern: ^[A-Z][-a-zA-Z0-9]*$
    ConstraintDescription: must begin with an upper case letter and contain alphanumeric characters and dashes.
  LogRetention:
    Description: Number of days to retain CloudWatch Log Events for all AMI Lookup Lambda Functions
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: 'must be: 1, 3, 5, 7, 14, 30, 60 or 90.'
Resources:
  Role:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DescribeSubnetsPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeSubnets
                Resource: '*'
  SubnetCalculatorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/SubnetCalculator
      RetentionInDays: !Ref LogRetention
  SubnetCalculatorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: SubnetCalculator
      Description: A Lambda function which calculates Subnet CIDRs for use in a VPC, based on the VPC CIDR, Addresses per Subnet, Subnets per Availability Zone and Availability Zones.
      Role: !GetAtt Role.Arn
      Runtime: nodejs8.10
      Timeout: 30
      Layers:
        - !ImportValue
            Fn::Sub: ${LayersStackName}-AsyncCustomResourceLayerVersionArn
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response-promise');

          const addressesToNetmask = {
            '16':    '28',
            '32':    '27',
            '64':    '26',
            '128':   '25',
            '256':   '24',
            '512':   '23',
            '1024':  '22',
            '2048':  '21',
            '4096':  '20',
            '8192':  '19',
            '16384': '18',
            '32768': '17',
            '65536': '16'
          };

          exports.handler = async (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                try {
                  const vpcCidrBlock = event.ResourceProperties.VpcCidrBlock;
                  if (! /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(1[6-9]|2[0-7]))$/.test(vpcCidrBlock)) {
                    throw new Error(`VpcCidrBlock invalid: must be a valid IP CIDR range of the form x.x.x.x/x, with a size from /16 to /27`);
                  }
                  const addresses = parseInt(event.ResourceProperties.Addresses, 10);
                  if (! /^(16|32|64|128|256|512|1024|2048|4096)$/.test(addresses)) {
                    throw new Error(`Addresses invalid: must be 16, 32, 64, 128, 256, 512, 1024, 2048 or 4096`);
                  }
                  const subnets = parseInt(event.ResourceProperties.Subnets, 10);
                  if (! /^(2|4|8|16|32|64)$/.test(subnets)) {
                    throw new Error(`Subnets invalid: must be 2, 4, 8, 16, 32 or 64`);
                  }
                  const zones = parseInt(event.ResourceProperties.AvailabilityZones, 10);
                  if (! /^(1|2|4)$/.test(zones)) {
                    throw new Error(`AvailabilityZones invalid: must be 1, 2 or 4`);
                  }

                  const vpcOctets = vpcCidrBlock.split('/')[0].split('.');
                  const vpcNetmask = vpcCidrBlock.split('/')[1];
                  const vpcDecimal = ((((((+vpcOctets[0]) * 256) + (+vpcOctets[1])) * 256) + (+vpcOctets[2])) * 256) + (+vpcOctets[3]);

                  if (vpcDecimal % Math.pow(2, 32 - vpcNetmask) !== 0) {
                    throw new Error(`VpcCidrBlock invalid: not aligned on the correct boundary for a /${vpcNetmask} netmask`);
                  }

                  const vpcRequestedAddresses = addresses * subnets * zones;
                  const vpcRequestedNetmask = addressesToNetmask[vpcRequestedAddresses];

                  if (vpcNetmask != vpcRequestedNetmask) {
                    throw new Error(`VpcCidrBlock invalid: incorrect size - a /${vpcRequestedNetmask} netmask is needed`);
                  }

                  let responseData = {};
                  for (let zone = 0; zone < zones; zone++) {
                    for (let subnet = 0; subnet < subnets; subnet++) {
                      const subnetDecimal = vpcDecimal + (addresses * (subnet + (subnets * zone)));
                      responseData[`Subnet${subnet}${String.fromCharCode(65 + zone)}`]
                        = (subnetDecimal >>> 24)       + '.'
                        + (subnetDecimal >>  16 & 255) + '.'
                        + (subnetDecimal >>   8 & 255) + '.'
                        + (subnetDecimal        & 255) + '/'
                        + addressesToNetmask[addresses];
                    }
                  }

                  await response.send(event, context, response.SUCCESS, responseData);
                }
                catch (err) {
                  const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                  console.error(responseData.Error);
                  await response.send(event, context, response.FAILED, responseData);
                }
                break;

              case 'Delete':
                await response.send(event, context, response.SUCCESS);
            }
          };
  AddressCalculatorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/AddressCalculator
      RetentionInDays: !Ref LogRetention
  AddressCalculatorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: AddressCalculator
      Description: A Lambda function which calculates Addresses for use in a VPC Subnet, based on the Subnet CIDR obtained from a Subnet ID.
      Role: !GetAtt Role.Arn
      Runtime: nodejs8.10
      Timeout: 30
      Layers:
        - !ImportValue
            Fn::Sub: ${LayersStackName}-AsyncCustomResourceLayerVersionArn
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response-promise');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            ec2: '2016-11-15'
          };

          exports.handler = async (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                try {
                  const region = event.ResourceProperties.Region || process.env.AWS_REGION;
                  const subnetId = event.ResourceProperties.SubnetId;
                  if (! /^subnet-[0-9a-f]{17}$/.test(subnetId)) {
                    throw new Error(`SubnetId invalid: must be valid Subnet ID`);
                  }

                  const ec2 = new AWS.EC2({region: region});

                  console.info(`Calling: DescribeSubnets...`);
                  const params = {
                    Filters: [{ Name: 'subnet-id', Values: [subnetId]}]
                  };
                  const data = await ec2.describeSubnets(params.promise();

                  if (data.Subnets.length > 0) {
                    const subnetCidrBlock = data.Subnets[0].CidrBlock;
                    console.info(`Subnet: ${subnetId} = ${subnetCidrBlock}`);
                    const subnetAddress = subnetCidrBlock.split('/')[0];
                    const subnetNetmask = subnetCidrBlock.split('/')[1];
                    const subnetOctets = subnetAddress.split('.');
                    const subnetDecimal = ((((((+subnetOctets[0]) * 256) + (+subnetOctets[1])) * 256) + (+subnetOctets[2])) * 256) + (+subnetOctets[3]);

                    console.info(`Calculating: Addresses...`);
                    let responseData = {};
                    for (let offset = 4; offset < Math.pow(2, 32 - subnetNetmask) - 1; offset++) {
                      const addressDecimal = subnetDecimal + offset;
                      responseData[`Address${offset}`]
                        = (addressDecimal >>> 24)       + '.'
                        + (addressDecimal >>  16 & 255) + '.'
                        + (addressDecimal >>   8 & 255) + '.'
                        + (addressDecimal        & 255);
                    }
                    await response.send(event, context, response.SUCCESS, responseData);
                  }
                  else {
                    throw new Error(`Could not find ${subnetId} Subnet`);
                  }
                }
                catch (err) {
                  const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                  console.error(responseData.Error);
                  await response.send(event, context, response.FAILED, responseData);
                }
                break;

              case 'Delete':
                await response.send(event, context, response.SUCCESS);
            }
          };
Outputs:
  SubnetCalculatorFunctionArn:
    Description: The SubnetCalculator Lambda Function ARN
    Value: !GetAtt SubnetCalculatorFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-SubnetCalculatorFunctionArn
  AddressCalculatorFunctionArn:
    Description: The AddressCalculator Lambda Function ARN
    Value: !GetAtt AddressCalculatorFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-AddressCalculatorFunctionArn
