AWSTemplateFormatVersion: 2010-09-09
Description: Baseline-Baseline Template.
  This creates Baseline Resources needed before Stacks can be created.
  Only the ZipFile method for Lambda Function Code is supported in this Template - this Stack will be created before
  any S3 Buckets exist. Also, this template contains a HACK to create the BaselineLayer directly from Encoded Content
  as the normal Type only works with S3 Content. This Layer provides the cfn-response-promise Node.js module, which
  allows use of the async/await design pattern instead of the older callback pattern. This layer is only used by
  other Baseline or Codes Functions, and should be removed if CloudFormation adds this missing module at some point.
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Layer Configuration
        Parameters:
          - BaselineLayerName
          - BaselineLayerEncodedContent
      - Label:
          default: Function Configuration
        Parameters:
          - EncodedLayerVersionLogRetention
          - BillingAlarmThresholdCalculatorLogRetention
          - RandomPasswordLogRetention
          - SecureParameterLogRetention
          - MessageLogRetention
          - MetadataDownloaderLogRetention
          - SamlProviderLogRetention
    ParameterLabels:
      BaselineLayerName:
        default: Baseline Layer Name
      BaselineLayerEncodedContent:
        default: Baseline Layer Encoded Content
      EncodedLayerVersionLogRetention:
        default: EncodedLayerVersion Log Retention
      BillingAlarmThresholdCalculatorLogRetention:
        default: BillingAlarmThresholdCalculator Log Retention
      RandomPasswordLogRetention:
        default: RandomPassword Log Retention
      SecureParameterLogRetention:
        default: SecureParameter Log Retention
      MessageLogRetention:
        default: Message Log Retention
      MetadataDownloaderLogRetention:
        default: MetadataDownloader Log Retention
      SamlProviderLogRetention:
        default: SamlProvider Log Retention
Parameters:
  BaselineLayerName:
    Description: Name of the Baseline Layer
    Type: String
    Default: BaselineLayer
    AllowedValues:
      - BaselineLayer
    ConstraintDescription: must be BaselineLayer.
  BaselineLayerEncodedContent:
    Description: Content of the Baseline Layer as a Base64-encoded string (Default is BaselineLayer.zip)
    Type: String
    Default: "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\
      AFBLBQYAAAAABAAEAI0BAADUBAAAAAA="
    ConstraintDescription: must be a Base64-encrypted string, containing the Layer archive content.
  EncodedLayerVersionLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the EncodedLayerVersion Lambda Function
    Type: Number
    Default: 3
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  BillingAlarmThresholdCalculatorLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the BillingAlarmThresholdCalculator Lambda Function
    Type: Number
    Default: 365
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
      - 120
      - 365
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60, 90 120 or 365.
  RandomPasswordLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the RandomPassword Lambda Function
    Type: Number
    Default: 1
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  SecureParameterLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the SecureParameter Lambda Function
    Type: Number
    Default: 1
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  MessageLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the Message Lambda Function
    Type: Number
    Default: 1
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  MetadataDownloaderLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the MetadataDownloader Lambda Function
    Type: Number
    Default: 1
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  SamlProviderLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the SamlProvider Lambda Function
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
Conditions:
  ConfigureGlobal: !Equals [ !Ref 'AWS::Region', us-east-1 ]
Resources:
  EncodedLayerVersionRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ManageLambdaLayers
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: ListLayers
                Effect: Allow
                Action:
                  - lambda:ListLayerVersions
                Resource: '*'
              - Sid: PublishLayers
                Effect: Allow
                Action:
                  - lambda:PublishLayerVersion
                Resource: !Sub arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:layer:Baseline*
              - Sid: ManageLayerVersions
                Effect: Allow
                Action:
                  - lambda:GetLayerVersion
                  - lambda:DeleteLayerVersion
                Resource: !Sub arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:layer:Baseline*:*
  EncodedLayerVersionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/EncodedLayerVersion
      RetentionInDays: !Ref EncodedLayerVersionLogRetention
  EncodedLayerVersionFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: EncodedLayerVersion
      Description: A Lambda function which creates a Lambda LayerVersion from Base64-encoded Content.
      Role: !GetAtt EncodedLayerVersionRole.Arn
      Runtime: nodejs8.10
      Timeout: 30
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            lambda: '2015-03-31'
          };

          const lambda = new AWS.Lambda();

          exports.handler = (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            const layerName = event.ResourceProperties.LayerName;
            if (! layerName) {
              const responseData = {Error: `LayerName missing`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }
            const content = event.ResourceProperties.Content.replace(/ /g, '');
            if (! content && event.RequestType != 'Delete') {
              const responseData = {Error: `Content missing`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            let params = {};
            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                console.info(`Calling: PublishLayerVersion...`);
                params = {
                  LayerName: layerName,
                  Content: {
                    ZipFile: Buffer.from(content, 'base64')
                  }
                };
                if (event.ResourceProperties.Description) params.Description = event.ResourceProperties.Description;
                if (event.ResourceProperties.LicenseInfo) params.LicenseInfo = event.ResourceProperties.LicenseInfo;
                if (event.ResourceProperties.CompatibleRuntimes) params.CompatibleRuntimes = event.ResourceProperties.CompatibleRuntimes;
                lambda.publishLayerVersion(params, (err, data) => {
                  if (err) {
                    const responseData = {Error: `PublishLayerVersion call failed`};
                    console.error(`Error: ${responseData.Error}:\n${err}`);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    const layerVersionArn = data.LayerVersionArn;
                    const codeSha256 = data.Content.CodeSha256;
                    const responseData = {CodeSha256: codeSha256};
                    console.info(`LayerVersion: ${layerVersionArn} created, Code SHA-256: ${codeSha256}`);
                    response.send(event, context, response.SUCCESS, responseData, layerVersionArn, false);
                  }
                });
                break;

              case 'Delete':
                console.info(`Calling: ListLayerVersions...`);
                  params = {
                    LayerName: layerName
                  };
                  lambda.listLayerVersions(params, function(err, data) {
                  if (err) {
                    const responseData = {Error: `ListLayerVersions call failed`};
                    console.error(`Error: ${responseData.Error}:\n${err}`);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    const layerVersions = data.LayerVersions.map(lv => lv.Version);
                    let deletePromises = [];
                    for (const layerVersion of layerVersions) {
                      params = {
                        LayerName: layerName,
                        VersionNumber: layerVersion
                      };
                      deletePromises.push(lambda.deleteLayerVersion(params).promise());
                    }
                    console.info(`Waiting for ${deletePromises.length} DeleteLayerVersion calls to finish...`);
                    Promise.all(deletePromises).then(results => {
                      console.info('LayerVersions deleted');
                      response.send(event, context, response.SUCCESS);
                    }).catch(err => {
                      const responseData = {Error: `Could not delete all LayerVersions`};
                      console.error(`Error: ${responseData.Error}:\n${err}`);
                      response.send(event, context, response.FAILED, responseData);
                    });
                  }
                });
            }
          };
  BaselineLayerVersion:
    Type: Custom::EncodedLayerVersion
    Properties:
      ServiceToken: !GetAtt EncodedLayerVersionFunction.Arn
      LayerName: !Ref BaselineLayerName
      Description: A Lambda layer version which contains the cfn-response-promise module, needed to write Lambda Functions
        which use the async/await coding style instead of callbacks.
      LicenseInfo: MIT
      CompatibleRuntimes:
        - nodejs8.10
        - nodejs10.x
      Content: !Ref BaselineLayerEncodedContent
  BillingAlarmThresholdCalculatorRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
    Condition: ConfigureGlobal
  BillingAlarmThresholdCalculatorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/BilingAlarmThresholdCalculator
      RetentionInDays: !Ref BillingAlarmThresholdCalculatorLogRetention
    Condition: ConfigureGlobal
  BillingAlarmThresholdCalculatorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: BilingAlarmThresholdCalculator
      Description: A Lambda function which calculates Billing Alarm Thresholds for use in Billing Alarms. This calculates a set of Values which can be used to set Alarm Thresholds, based on Low, Normal and High Values.
      Role: !GetAtt BillingAlarmThresholdCalculatorRole.Arn
      Runtime: nodejs8.10
      Timeout: 30
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response');

          exports.handler = (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            if (event.RequestType == 'Delete') {
              response.send(event, context, response.SUCCESS);
              return;
            }

            console.info(`Validating: Parameters...`);
            const lowAmount = (event.ResourceProperties.LowAmount) ? Number(event.ResourceProperties.LowAmount) : 0;
            if (! Number.isInteger(lowAmount) || lowAmount < 0 || lowAmount % 10) {
              const responseData = {Error: `LowAmount invalid: must be a positive integer divisible by 10 or 0`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            const normalAmount = (event.ResourceProperties.NormalAmount) ? Number(event.ResourceProperties.NormalAmount) : 'invalid';
            if (! Number.isInteger(normalAmount) || normalAmount < 0 || normalAmount <= lowAmount || normalAmount % 10) {
              const responseData = {Error: `NormalAmount invalid: must be a positive integer divisible by 10 and greater than LowAmount`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            const highAmount = (event.ResourceProperties.HighAmount) ? Number(event.ResourceProperties.HighAmount) : normalAmount * 1.2;
            if (! Number.isInteger(highAmount) || highAmount < 0 || highAmount <= normalAmount || highAmount % 10) {
              const responseData = {Error: `HighAmount invalid: must be a positive integer divisible by 10 and greater than NormalAmount`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            const normalAlarms = (event.ResourceProperties.NormalAlarms) ? Number(event.ResourceProperties.NormalAlarms) : 5;
            if (! /^(5|10|20)$/.test(normalAlarms)) {
              const responseData = {Error: `NormalAlarms invalid: must be 5, 10 or 20`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            const highAlarms = (event.ResourceProperties.HighAlarms) ? Number(event.ResourceProperties.HighAlarms) : 5;
            if (! /^(5|10|20)$/.test(highAlarms)) {
              const responseData = {Error: `HighAlarms invalid: must be 5, 10 or 20`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            if ((normalAmount - lowAmount) < normalAlarms) {
              const responseData = {Error: `NormalAlarms invalid: NormalAmount - LowAmount must be greater than or equal to NormalAlarms`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            if ((highAmount - normalAmount) < highAlarms) {
              const responseData = {Error: `HighAlarms invalid: HighAmount - NormalAmount must be greater than or equal to HighAlarms`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            console.info(`Calculating Alarm Threshholds...`);
            let responseData = {};
            for (let alarm = 1; alarm <= normalAlarms; alarm++) {
              console.info(`Normal${alarm.toString().padStart(2,'0')}: ${(lowAmount + Math.round(((normalAmount - lowAmount) / normalAlarms) * alarm))}`);
              responseData[`Normal${alarm.toString().padStart(2,'0')}`] = lowAmount + Math.round(((normalAmount - lowAmount) / normalAlarms) * alarm);
            }

            for (let alarm = 1; alarm <= highAlarms; alarm++) {
              console.info(`High${alarm.toString().padStart(2,'0')}: ${(normalAmount + Math.round(((highAmount - normalAmount) / highAlarms) * alarm))}`);
              responseData[`High${alarm.toString().padStart(2,'0')}`] = normalAmount + Math.round(((highAmount - normalAmount) / highAlarms) * alarm);
            }

            response.send(event, context, response.SUCCESS, responseData);
          };
    Condition: ConfigureGlobal
  RandomPasswordRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AllowRandomPasswordGeneration
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetRandomPassword
                Resource: '*'
  RandomPasswordLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/RandomPassword
      RetentionInDays: !Ref RandomPasswordLogRetention
  RandomPasswordFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: RandomPassword
      Description: A Lambda function that generates a random password using the SecretsManager getRandomPassword method.
      Role: !GetAtt RandomPasswordRole.Arn
      Runtime: nodejs8.10
      Timeout: 30
      Handler: index.handler
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            secretsmanager: '2017-10-17'
          };

          const secretsmanager = new AWS.SecretsManager();

          const parseBoolean = (value) => {
            const re=/^(t(rue)?|1|on|y(es)?)$/i;
            return re.test(value);
          };

          const response = {};
          response.SUCCESS = "SUCCESS";
          response.FAILED = "FAILED";
          response.send = function(event, context, responseStatus, responseData, physicalResourceId, noEcho) {
            var responseBody = JSON.stringify({
              Status: responseStatus,
              Reason: "See the details in CloudWatch Log Stream: " + context.logStreamName,
              PhysicalResourceId: physicalResourceId || context.logStreamName,
              StackId: event.StackId,
              RequestId: event.RequestId,
              LogicalResourceId: event.LogicalResourceId,
              NoEcho: noEcho || false,
              Data: responseData
            });

            var https = require("https");
            var url = require("url");

            var parsedUrl = url.parse(event.ResponseURL);
            var options = {
              hostname: parsedUrl.hostname,
              port: 443,
              path: parsedUrl.path,
              method: "PUT",
              headers: {
                "content-type": "",
                "content-length": responseBody.length
              }
            };

            var request = https.request(options, function(response) {
              console.log("Status code: " + response.statusCode);
              console.log("Status message: " + response.statusMessage);
              context.done();
            });

            request.on("error", function(error) {
              console.log("send(..) failed executing https.request(..): " + error);
              context.done();
            });

            request.write(responseBody);
            request.end();
          };

          exports.handler = (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            let params = {};
            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                console.info(`Calling: GetRandomPassword...`);
                if (event.ResourceProperties.PasswordLength) params.PasswordLength = Math.max(parseInt(event.ResourceProperties.PasswordLength, 10), 8);
                if (event.ResourceProperties.ExcludeUppercase) params.ExcludeUppercase = parseBoolean(event.ResourceProperties.ExcludeUppercase);
                if (event.ResourceProperties.ExcludeLowercase) params.ExcludeLowercase = parseBoolean(event.ResourceProperties.ExcludeLowercase);
                if (event.ResourceProperties.ExcludeNumbers) params.ExcludeNumbers = parseBoolean(event.ResourceProperties.ExcludeNumbers);
                if (event.ResourceProperties.ExcludePunctuation) params.ExcludePunctuation = parseBoolean(event.ResourceProperties.ExcludePunctuation);
                if (event.ResourceProperties.IncludeSpace) params.IncludeSpace = parseBoolean(event.ResourceProperties.IncludeSpace);
                if (event.ResourceProperties.RequireEachIncludedType) params.RequireEachIncludedType = parseBoolean(event.ResourceProperties.RequireEachIncludedType);
                if (event.ResourceProperties.ExcludeCharacters) params.ExcludeCharacters = event.ResourceProperties.ExcludeCharacters;
                secretsmanager.getRandomPassword(params, (err, data) => {
                  if (err) {
                    const responseData = {Error: `GetRandomPassword call failed`};
                    console.error(`Error: ${responseData.Error}:\n${err}`);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    const password = data.RandomPassword;
                    const s = Math.max(Math.min(Math.floor(password.length/4), 4), 1);
                    const m = password.length - 2 * s;
                    const obfuscatedPassword = password.replace(password.substr(s,m), '*'.repeat(m));
                    const responseData = {Password: password};
                    console.info(`RandomPassword: ${obfuscatedPassword} created`);
                    response.send(event, context, response.SUCCESS, responseData, obfuscatedPassword, true);
                  }
                });
                break;

              case 'Delete':
                response.send(event, context, response.SUCCESS);
            }
          };
  SecureParameterRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ManageSSMParameter
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ssm:PutParameter
                  - ssm:DeleteParameter
                  - kms:Encrypt
                Resource: '*'
  SecureParameterLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/SecureParameter
      RetentionInDays: !Ref SecureParameterLogRetention
  SecureParameterFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: SecureParameter
      Description: A Lambda function that handles an SSM SecureString Parameter as a CustomResource, as this parameter Type is not currently supported.
      Role: !GetAtt SecureParameterRole.Arn
      Runtime: nodejs8.10
      Timeout: 30
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            ssm: '2014-11-06'
          };

          const ssm = new AWS.SSM();

          exports.handler = (event, context) => {
            const obfuscatedEvent = {};
            Object.assign(obfuscatedEvent, event);
            obfuscatedEvent.ResourceProperties = {};
            Object.assign(obfuscatedEvent.ResourceProperties, event.ResourceProperties);
            obfuscatedEvent.ResourceProperties.Value = event.ResourceProperties.Value.replace(/./g, '*');

            console.info(`Request Body:\n${JSON.stringify(obfuscatedEvent)}`);

            const name = event.ResourceProperties.Name || `${event.StackId.split(':')[5].split('/')[1]}-${event.LogicalResourceId}`;
            if (! name) {
              const responseData = {Error: `Name missing`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }
            const value = event.ResourceProperties.Value;
            if (! value && event.RequestType != 'Delete') {
              const responseData = {Error: `Value missing`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }
            const allowedPattern = event.ResourceProperties.AllowedPattern;
            const description = event.ResourceProperties.Description;

            let params = {};
            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                console.info(`Calling: PutParameter...`);
                params = {
                  Name: name,
                  Type: 'SecureString',
                  Value: value,
                  Overwrite: (event.RequestType == 'Create') ? false : true
                };
                if (allowedPattern) params.AllowedPattern = allowedPattern;
                if (description) params.Description = description;
                ssm.putParameter(params, (err, data) => {
                  if (err) {
                    const responseData = {Error: `PutParameter call failed`};
                    console.error(`Error: ${responseData.Error}:\n${err}`);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    console.info(`SecureParameter: ${name} created`);
                    response.send(event, context, response.SUCCESS, null, name);
                  }
                });
                break;

              case 'Delete':
                console.info(`Calling: DeleteParameter...`);
                params = {
                  Name: name
                };
                ssm.deleteParameter(params, (err, data) => {
                  if (err) {
                    const responseData = {Error: `DeleteParameter call failed`};
                    console.error(`Error: ${responseData.Error}:\n${err}`);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    console.info(`Parameter: deleted`);
                    response.send(event, context, response.SUCCESS);
                  }
                });
                break;

              default:
                const responseData = {Error: `Unknown operation: ${event.RequestType}`};
                console.error(`Error: ${responseData.Error}`);
                response.send(event, context, response.FAILED, responseData);
            }
          };
  MessageRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AllowPublish
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource: '*'
  MessageLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/Message
      RetentionInDays: !Ref MessageLogRetention
  MessageFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: Message
      Description: A Lambda function that publishes a message to an SNS Topic.
      Role: !GetAtt MessageRole.Arn
      Runtime: nodejs8.10
      Timeout: 30
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            sns: '2010-03-31'
          };

          const sns = new AWS.SNS();

          exports.handler = (event, context) => {
            console.info(`Request Body:\n${JSON.stringify(event)}`);

            const topicArn = event.ResourceProperties.TopicArn;
            if (! topicArn) {
              const responseData = {Error: `TopicArn missing`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            const message = event.ResourceProperties.Message;
            if (! message) {
              const responseData = {Error: `Message missing`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            let params = {};
            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                console.info(`Calling: Publish...`);
                params = {
                  TopicArn: topicArn,
                  Message: message
                };
                sns.publish(params, (err, data) => {
                  if (err) {
                    const responseData = {Error: `Publish call failed`};
                    console.error(`Error: ${responseData.Error}:\n${err}`);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    const messageId = data.MessageId;
                    console.info(`Message: ${messageId} sent`);
                    response.send(event, context, response.SUCCESS, null, messageId);
                  }
                });
                break;

              case 'Delete':
                response.send(event, context, response.SUCCESS);
                break;

              default:
                const responseData = {Error: `Unknown operation: ${event.RequestType}`};
                console.error(`Error: ${responseData.Error}`);
                response.send(event, context, response.FAILED, responseData);
            }
          };
  MetadataDownloaderRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
  MetadataDownloaderLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/MetadataDownloader
      RetentionInDays: !Ref MetadataDownloaderLogRetention
  MetadataDownloaderFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: MetadataDownloader
      Description: A Lambda function that can download Metadata from an URL.
      Role: !GetAtt MetadataDownloaderRole.Arn
      Runtime: nodejs8.10
      Timeout: 30
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response');

          const getContent = (url) => {
            return new Promise((resolve, reject) => {
              const lib = url.startsWith('https') ? require('https') : require('http');
              const request = lib.get(url, (response) => {
                if (response.statusCode < 200 || response.statusCode > 299) {
                   reject(new Error(`Failed to load page, status code: ${response.statusCode}`));
              }

                const body = [];
                response.on('data', (chunk) => body.push(chunk));
                response.on('end', () => resolve(body.join('')));
              });

              request.on('error', (err) => reject(err));
              });
          };

          exports.handler = (event, context) => {
            console.info(`Request Body:\n${JSON.stringify(event)}`);

            const metadataUrl = event.ResourceProperties.MetadataUrl;
            if (! metadataUrl) {
              const responseData = {Error: `MetadataUrl missing`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                getContent(metadataUrl).then(function(data) {
                  const responseData = {Metadata: data};
                  console.info(`Downloaded Metadata from: ${metadataUrl}`);
                  response.send(event, context, response.SUCCESS, responseData, metadataUrl);
                }).catch(function(err) {
                  const responseData = {Error: `Failed to download Metadata from ${metadataUrl}`};
                  console.error(`Error: ${responseData.Error}:\n${err}`);
                  response.send(event, context, response.FAILURE, responseData);
                });
                return;

              case 'Delete':
                response.send(event, context, response.SUCCESS);
                return;

              default:
                const responseData = {Error: `Unknown operation: ${event.RequestType}`};
                console.error(`Error: ${responseData.Error}`);
                response.send(event, context, response.FAILED, responseData);
                return;
            }
          };
  SamlProviderRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ManageSamlProviderPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - iam:ListSamlProviders
                  - iam:GetSamlProvider
                  - iam:CreateSamlProvider
                  - iam:UpdateSamlProvider
                  - iam:DeleteSamlProvider
                Resource: "*"
    Condition: ConfigureGlobal
  SamlProviderLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/SamlProvider
      RetentionInDays: !Ref SamlProviderLogRetention
    Condition: ConfigureGlobal
  SamlProviderFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: SamlProvider
      Description: A Lambda function that can create, update or delete an IAM SAML Identity Provider.
      Role: !GetAtt SamlProviderRole.Arn
      Runtime: nodejs8.10
      Timeout: 30
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            iam: '2010-05-08'
          };

          const iam = new AWS.IAM();

          exports.handler = (event, context) => {
            console.info(`Request Body:\n${JSON.stringify(event)}`);

            const providerName = event.ResourceProperties.ProviderName;
            if (! providerName) {
              const responseData = {Error: `ProviderName missing`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            const providerMetadata = event.ResourceProperties.ProviderMetadata;
            if (! providerMetadata && event.RequestType != 'Delete') {
              const responseData = {Error: `ProviderMetadata missing`};
              console.error(`Error: ${responseData.Error}`);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            const accountId=event.StackId.split(':')[4];

            let params = {};
            switch (event.RequestType) {
              case 'Create':
                console.info(`Calling: CreateSAMLProvider...`);
                params = {
                  Name: providerName,
                  SAMLMetadataDocument: providerMetadata
                };
                iam.createSAMLProvider(params, (err, data) => {
                  if (err) {
                    const responseData = {Error: `CreateSAMLProvider call failed`};
                    console.error(`Error: ${responseData.Error}:\n${err}`);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    const responseData = {Arn: data.SAMLProviderArn};
                    console.info(`SAML Provider: ${data.SAMLProviderArn} created`);
                    response.send(event, context, response.SUCCESS, responseData, data.SAMLProviderArn);
                  }
                });
                break;

              case 'Update':
                console.info(`Calling: UpdateSAMLProvider...`);
                params = {
                  SAMLProviderArn: `arn:aws:iam::${accountId}:saml-provider/${providerName}`,
                  SAMLMetadataDocument: providerMetadata
                };
                iam.updateSAMLProvider(params, (err, data) => {
                  if (err) {
                    const responseData = {Error: `UpdateSAMLProvider call failed`};
                    console.error(`Error: ${responseData.Error}:\n${err}`);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    const responseData = {Arn: data.SAMLProviderArn};
                    console.info(`SAML Provider: ${data.SAMLProviderArn} updated`);
                    response.send(event, context, response.SUCCESS, responseData, data.SAMLProviderArn);
                  }
                });
                break;

              case 'Delete':
                console.info(`Calling: DeleteSAMLProvider...`);
                params = {
                  SAMLProviderArn: `arn:aws:iam::${accountId}:saml-provider/${providerName}`
                };
                iam.deleteSAMLProvider(params, (err, data) => {
                  if (err) {
                    const responseData = {Error: `DeleteSAMLProvider call failed`};
                    console.error(`Error: ${responseData.Error}:\n${err}`);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    console.info(`SAML Provider: deleted`);
                    response.send(event, context, response.SUCCESS);
                  }
                });
                break;

              default:
                const responseData = {Error: `Unknown operation: ${event.RequestType}`};
                console.error(`Error: ${responseData.Error}`);
                response.send(event, context, response.FAILED, responseData);
            }
          };
    Condition: ConfigureGlobal
Outputs:
  EncodedLayerVersionFunctionArn:
    Description: The EncodedLayerVersion Lambda Function ARN
    Value: !GetAtt EncodedLayerVersionFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-EncodedLayerVersionFunctionArn
  BaselineLayerVersionArn:
    Description: The BaselineLayerVersion ARN
    Value: !Ref BaselineLayerVersion
    Export:
      Name: !Sub ${AWS::StackName}-BaselineLayerVersionArn
  BillingAlarmThresholdCalculatorFunctionArn:
    Description: The BillingAlarmThresholdCalculator Lambda Function ARN
    Value: !GetAtt BillingAlarmThresholdCalculatorFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-BillingAlarmThresholdCalculatorFunctionArn
    Condition: ConfigureGlobal
  RandomPasswordFunctionArn:
    Description: The RandomPassword Lambda Function ARN
    Value: !GetAtt RandomPasswordFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-RandomPasswordFunctionArn
  SecureParameterFunctionArn:
    Description: The SecureParameter Lambda Function ARN
    Value: !GetAtt SecureParameterFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-SecureParameterFunctionArn
  MessageFunctionArn:
    Description: The Message Lambda Function ARN
    Value: !GetAtt MessageFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-MessageFunctionArn
  MetadataDownloaderFunctionArn:
    Description: The MetadataDownloader Lambda Function ARN
    Value: !GetAtt MetadataDownloaderFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-MetadataDownloaderFunctionArn
  SamlProviderFunctionArn:
    Description: The SamlProvider Lambda Function ARN
    Value: !GetAtt SamlProviderFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-SamlProviderFunctionArn
    Condition: ConfigureGlobal
